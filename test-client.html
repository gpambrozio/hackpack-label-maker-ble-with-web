<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Label Maker Client</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <div class="bg-white p-8 rounded-xl shadow-lg w-full max-w-5xl">
        <h1 class="text-2xl font-bold mb-6 text-center">Label Maker Control</h1>
        <div class="flex flex-col space-y-4">
            <button id="connectButton" class="bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 transition-colors">
                Connect to Device
            </button>

            <!-- Pen Controls -->
            <div class="grid grid-cols-2 gap-3">
                <button id="penDownButton" class="bg-amber-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-amber-700 transition-colors" disabled>
                    Pen Down
                </button>
                <button id="penUpButton" class="bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-slate-700 transition-colors" disabled>
                    Pen Up
                </button>
            </div>

            <!-- Print Text -->
            <div class="flex items-center space-x-2">
                <input id="labelText" type="text" placeholder="Enter label text" class="w-full max-w-full px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-shadow" />
                <button id="sendTextButton" class="bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-green-700 transition-colors" disabled>
                    Send Text
                </button>
            </div>

            <!-- G-code editor + preview -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="flex flex-col space-y-2">
                    <label for="gcodeTextarea" class="text-sm font-semibold text-gray-700">G-code (mm, origin at bottom-left)</label>
                    <textarea id="gcodeTextarea" rows="12" class="w-full px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-purple-500 font-mono text-sm" placeholder="Enter G-code here"></textarea>
                    <div class="flex items-center gap-2">
                        <button id="sendSampleGcodeButton" class="bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-purple-700 transition-colors" disabled>
                            Send G-code
                        </button>
                        <button id="resetToSampleButton" class="bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition-colors" type="button">
                            Reset to Sample
                        </button>
                    </div>
                </div>
                <div class="flex flex-col space-y-2">
                    <div class="flex items-center justify-between">
                        <span class="text-sm font-semibold text-gray-700">Preview (SVG)</span>
                        <span class="text-xs text-gray-500">Area: 260 × 30 mm</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <label for="thicknessSlider" class="text-xs text-gray-600">Tool thickness</label>
                        <input id="thicknessSlider" type="range" min="0.2" max="5" step="0.1" value="2" class="w-40">
                        <span id="thicknessValue" class="text-xs text-gray-500">2.0 mm</span>
                    </div>
                    <div class="border rounded-lg overflow-auto bg-white p-4">
                        <svg id="gcodePreview" class="overflow-visible" width="260mm" height="30mm" viewBox="0 0 260 30" preserveAspectRatio="xMidYMid meet"></svg>
                    </div>
                </div>
            </div>

            <button id="disconnectButton" class="bg-red-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-red-700 transition-colors" disabled>
                Disconnect
            </button>
        </div>
        <div id="status" class="mt-6 p-4 bg-gray-100 rounded-lg text-sm text-gray-700">
            Status: Ready to connect.
        </div>
    </div>

    <script>
        // Global variables to hold the device and characteristic
        let labelMakerDevice = null;
        let labelMakerCharacteristic = null;

        // UUIDs from the Arduino code
        const SERVICE_UUID = '12345678-1234-5678-1234-56789abcdef0';
        const CHARACTERISTIC_UUID = '87654321-4321-8765-4321-87654321fedc';

        // Get UI elements
    const connectButton = document.getElementById('connectButton');
    const penDownButton = document.getElementById('penDownButton');
    const penUpButton = document.getElementById('penUpButton');
    const sendTextButton = document.getElementById('sendTextButton');
    const sendSampleGcodeButton = document.getElementById('sendSampleGcodeButton');
    const disconnectButton = document.getElementById('disconnectButton');
    const labelTextInput = document.getElementById('labelText');
    const statusDiv = document.getElementById('status');
    const gcodeTextarea = document.getElementById('gcodeTextarea');
    const resetToSampleButton = document.getElementById('resetToSampleButton');
    const gcodePreview = document.getElementById('gcodePreview');
    const thicknessSlider = document.getElementById('thicknessSlider');
    const thicknessValue = document.getElementById('thicknessValue');

    // Preview stroke width in mm
    let currentStrokeWidth = 2.0;

        /**
         * Updates the status message on the UI.
         * @param {string} message The message to display.
         * @param {string} color The Tailwind CSS text color class.
         */
        const updateStatus = (message, color = 'text-gray-700') => {
            statusDiv.textContent = `Status: ${message}`;
            statusDiv.className = `mt-6 p-4 bg-gray-100 rounded-lg text-sm ${color}`;
        };

        /**
         * Connects to the Bluetooth device.
         */
        const connectDevice = async () => {
            try {
                updateStatus('Connecting...');
                
                // Request a Bluetooth device
                labelMakerDevice = await navigator.bluetooth.requestDevice({
                    // filters: [{ namePrefix: 'LABEL' }],
                    acceptAllDevices: true,
                    optionalServices: [SERVICE_UUID]
                });

                // Add event listener for device disconnects
                labelMakerDevice.addEventListener('gattserverdisconnected', onDisconnected);

                // Connect to the GATT server
                updateStatus('Connecting to GATT server...');
                const server = await labelMakerDevice.gatt.connect();

                // Get the primary service
                updateStatus('Getting service...');
                const service = await server.getPrimaryService(SERVICE_UUID);

                // Get the characteristic
                updateStatus('Getting characteristic...');
                labelMakerCharacteristic = await service.getCharacteristic(CHARACTERISTIC_UUID);

                updateStatus('Connected successfully!', 'text-green-600');
                
                // Enable UI elements after successful connection
                connectButton.disabled = true;
                penDownButton.disabled = false;
                penUpButton.disabled = false;
                sendTextButton.disabled = false;
                sendSampleGcodeButton.disabled = false;
                disconnectButton.disabled = false;

            } catch (error) {
                updateStatus(`Connection failed: ${error}`, 'text-red-600');
                console.error('Connection error:', error);
            }
        };

        /**
         * Write a command string to the device characteristic.
         */
        const writeCommand = async (command) => {
            if (!labelMakerCharacteristic) {
                updateStatus('Not connected.', 'text-red-600');
                return;
            }
            try {
                updateStatus('Sending command...');
                const encoder = new TextEncoder();
                const data = encoder.encode(command);
                if (data.byteLength > 512) {
                    throw new Error(`Payload ${data.byteLength} exceeds 512 bytes`);
                }
                await labelMakerCharacteristic.writeValue(data);
                updateStatus(`Command sent: "${command.slice(0, 60)}${command.length > 60 ? '…' : ''}"`, 'text-blue-600');
            } catch (error) {
                updateStatus(`Failed to send command: ${error}`, 'text-red-600');
                console.error('Send command error:', error);
            }
        };

        // Write a potentially long G-code using chunked protocol
        const sendGcodeChunked = async (program) => {
            if (!labelMakerCharacteristic) {
                updateStatus('Not connected.', 'text-red-600');
                return;
            }
            const encoder = new TextEncoder();
            const MAX_PAYLOAD = 480; // leave headroom for command and comma
            try {
                // begin
                await writeCommand('print-raw-begin,');
                // stream chunks
                let i = 0;
                while (i < program.length) {
                    const slice = program.slice(i, i + MAX_PAYLOAD);
                    // send as print-raw-data,<chunk>
                    await writeCommand(`print-raw-data,${slice}`);
                    i += slice.length;
                }
                // end
                await writeCommand('print-raw-end,');
                updateStatus('G-code sent (chunked).', 'text-green-600');
            } catch (error) {
                updateStatus(`Chunked send failed: ${error}`, 'text-red-600');
                console.error('Chunked send error:', error);
            }
        };

        // Build a 5cm-wide ruler-like example with X & Y axes, cm and 0.5cm ticks, and numeric labels (as line strokes)
    // Origin (0,0) is bottom-left. Max area is 260x30 mm; height is capped.
        const buildSampleGcode = () => {
            const AREA_W = 260, AREA_H = 30;
            const MARGIN = 0; // no margin
            const L = MARGIN, B = MARGIN;
            const WIDTH = 50; // 5cm
            const HEIGHT = Math.min(AREA_H - 2 * MARGIN, 50); // cap to available height

            const AXIS_X0 = L, AXIS_Y0 = B;
            const AXIS_X1 = L + WIDTH, AXIS_Y1 = B + HEIGHT;

            const MAJOR = 4; // major tick length (cm)
            const MINOR = 2; // half-cm tick length (5mm)
            const GAP = 1.5; // gap before labels

            // Simple seven-segment digits as line segments within w x h box
            const DIGIT_W = 3, DIGIT_H = 5;
            const segs = {
                A: [0, DIGIT_H, DIGIT_W, DIGIT_H],
                B: [DIGIT_W, DIGIT_H, DIGIT_W, DIGIT_H/2],
                C: [DIGIT_W, DIGIT_H/2, DIGIT_W, 0],
                D: [0, 0, DIGIT_W, 0],
                E: [0, DIGIT_H/2, 0, 0],
                F: [0, DIGIT_H, 0, DIGIT_H/2],
                G: [0, DIGIT_H/2, DIGIT_W, DIGIT_H/2],
            };
            const map = {
                0: ['A','B','C','D','E','F'],
                1: ['B','C'],
                2: ['A','B','G','E','D'],
                3: ['A','B','G','C','D'],
                4: ['F','G','B','C'],
                5: ['A','F','G','C','D'],
                6: ['A','F','G','E','C','D'],
                7: ['A','B','C'],
                8: ['A','B','C','D','E','F','G'],
                9: ['A','B','C','D','F','G'],
            };

            const cmds = [];
            const moveRapid = (x,y) => { cmds.push(`M5`); cmds.push(`G0 X${x} Y${y}`); };
            const drawTo = (x,y) => { cmds.push(`M3`); cmds.push(`G1 X${x} Y${y}`); cmds.push(`M5`); };
            const drawLine = (x1,y1,x2,y2) => { moveRapid(x1,y1); drawTo(x2,y2); };
            const drawDigit = (n, ox, oy) => {
                const seglist = map[n]; if (!seglist) return;
                for (const s of seglist) {
                    const [x1,y1,x2,y2] = segs[s];
                    drawLine(ox + x1, oy + y1, ox + x2, oy + y2);
                }
            };

            // Program header
            cmds.push(`G90`); // absolute
            cmds.push(`M5`);

            // No border rectangle (drop top/right edges and margins)

            // Axes
            drawLine(AXIS_X0, AXIS_Y0, AXIS_X1, AXIS_Y0); // X axis
            drawLine(AXIS_X0, AXIS_Y0, AXIS_X0, AXIS_Y1); // Y axis

            // X-axis ticks and labels (every 5mm, labels at each cm)
            for (let i = 0; i <= WIDTH; i += 5) {
                const x = L + i;
                const len = (i % 10 === 0) ? MAJOR : MINOR;
                drawLine(x, B, x, B + len);
                if (i > 0 && i % 10 === 0) {
                    const n = Math.floor(i / 10);
                    // Center digit above tick
                    const dx = x - DIGIT_W / 2;
                    const dy = B + len + GAP;
                    drawDigit(n, dx, dy);
                }
            }

            // Y-axis ticks and labels (every 5mm, labels at each cm)
            const maxYcm = Math.floor(HEIGHT / 10);
            for (let j = 0; j <= HEIGHT; j += 5) {
                const y = B + j;
                const len = (j % 10 === 0) ? MAJOR : MINOR;
                drawLine(L, y, L + len, y);
                if (j > 0 && j % 10 === 0) {
                    const n = Math.floor(j / 10);
                    if (n <= 9) {
                        const dx = L + len + GAP;
                        // vertically center on tick, but keep fully within area height
                        let dy = y - DIGIT_H / 2;
                        const dyMin = B;
                        const dyMax = B + HEIGHT - DIGIT_H;
                        if (dy < dyMin) dy = dyMin;
                        if (dy > dyMax) dy = dyMax;
                        drawDigit(n, dx, dy);
                    }
                }
            }

            return cmds.join(';');
        };

        // --- G-code preview renderer (SVG) ---
    const MAX_X = 260, MAX_Y = 30;
        const clearNode = (node) => { while (node.firstChild) node.removeChild(node.firstChild); };
    const parseAndRenderGcode = (program) => {
            clearNode(gcodePreview);

            // Draw area border
            const border = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            border.setAttribute('x', '0');
            border.setAttribute('y', '0');
            border.setAttribute('width', String(MAX_X));
            border.setAttribute('height', String(MAX_Y));
            border.setAttribute('fill', 'white');
            border.setAttribute('stroke', '#e5e7eb');
            border.setAttribute('stroke-width', '0.4');
            gcodePreview.appendChild(border);

            // Flip Y so (0,0) is bottom-left visually
            const gg = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            gg.setAttribute('transform', `scale(1,-1) translate(0, -${MAX_Y})`);
            gcodePreview.appendChild(gg);

            let abs = true;
            let pen = false;
            let x = 0, y = 0;
            let path = '';
            const addSeg = (nx, ny) => {
                if (!pen) return;
                if (!path) path = `M ${x} ${y}`;
                path += ` L ${nx} ${ny}`;
            };

            const lines = program.split(/[;\n\r]+/);
            for (let raw of lines) {
                let line = raw.replace(/\(.*?\)/g, '').trim();
                if (!line) continue;
                if (line.startsWith(';')) continue;
                line = line.replace(/\s+/g, ' ').toUpperCase();
                const words = line.split(' ');
                const w0 = words[0];
                if (w0.startsWith('G')) {
                    const num = parseInt(w0.slice(1), 10) || 0;
                    let nx = x, ny = y;
                    for (let i = 1; i < words.length; i++) {
                        const w = words[i];
                        if (w.startsWith('X')) nx = parseFloat(w.slice(1));
                        else if (w.startsWith('Y')) ny = parseFloat(w.slice(1));
                    }
                    if (num === 90) { abs = true; continue; }
                    if (num === 91) { abs = false; continue; }
                    if (num === 0 || num === 1) {
                        const tx = abs ? nx : x + nx;
                        const ty = abs ? ny : y + ny;
                        const cx = Math.max(0, Math.min(MAX_X, tx));
                        const cy = Math.max(0, Math.min(MAX_Y, ty));
                        if (num === 1) addSeg(cx, cy);
                        x = cx; y = cy;
                    }
                } else if (w0.startsWith('M')) {
                    const num = parseInt(w0.slice(1), 10) || 0;
                    if (num === 3) { // pen down
                        // start new subpath at current pos always
                        if (path) path += ` M ${x} ${y}`; else path = `M ${x} ${y}`;
                        pen = true;
                    } else if (num === 5) { // pen up
                        pen = false;
                    } else if (num === 300) {
                        // M300 Sxx heuristic
                        let s = null;
                        for (let i = 1; i < words.length; i++) if (words[i].startsWith('S')) s = parseFloat(words[i].slice(1));
                        if (s !== null) {
                            const down = (s < 60);
                            if (down && !pen) {
                                if (path) path += ` M ${x} ${y}`; else path = `M ${x} ${y}`;
                                pen = true;
                            } else if (!down && pen) {
                                pen = false;
                            }
                        }
                    }
                }
            }

            if (path) {
                const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                p.setAttribute('d', path);
                p.setAttribute('fill', 'none');
                p.setAttribute('stroke', '#7c3aed');
                p.setAttribute('stroke-width', String(currentStrokeWidth));
                p.setAttribute('stroke-linecap', 'round');
                p.setAttribute('stroke-linejoin', 'round');
                gg.appendChild(p);
            }
        };

        // UI actions
        const sendPenDown = () => writeCommand('pen-down,');
        const sendPenUp = () => writeCommand('pen-up,');
        const sendText = () => {
            const txt = (labelTextInput.value || '').trim();
            if (!txt) {
                updateStatus('Enter some text to print.', 'text-red-600');
                return;
            }
            if (txt.length > 400) {
                updateStatus('Text too long for single BLE write. Keep under ~400 chars.', 'text-red-600');
                return;
            }
            writeCommand(`print-text,${txt}`);
            labelTextInput.value = '';
        };
        const sendSampleGcode = () => {
            const g = (gcodeTextarea.value || '').trim();
            if (!g) {
                updateStatus('No G-code to send.', 'text-red-600');
                return;
            }
            // decide chunking based on size
            if (g.length > 420) {
                sendGcodeChunked(g);
            } else {
                writeCommand(`print-raw,${g}`);
            }
        };
        const resetToSample = () => {
            const g = buildSampleGcode();
            gcodeTextarea.value = g;
            parseAndRenderGcode(g);
        };

        /**
         * Disconnects from the device.
         */
        const disconnectDevice = () => {
            if (labelMakerDevice && labelMakerDevice.gatt.connected) {
                labelMakerDevice.gatt.disconnect();
                updateStatus('Disconnected.', 'text-gray-700');
            } else {
                updateStatus('Device is already disconnected.', 'text-gray-700');
            }
        };

        /**
         * Handler for when the device unexpectedly disconnects.
         */
        const onDisconnected = (event) => {
            updateStatus('Device disconnected.', 'text-red-600');
            // Reset state
            labelMakerDevice = null;
            labelMakerCharacteristic = null;
            connectButton.disabled = false;
            penDownButton.disabled = true;
            penUpButton.disabled = true;
            sendTextButton.disabled = true;
            sendSampleGcodeButton.disabled = true;
            disconnectButton.disabled = true;
        };

        // Attach event listeners to buttons
        connectButton.addEventListener('click', connectDevice);
        penDownButton.addEventListener('click', sendPenDown);
        penUpButton.addEventListener('click', sendPenUp);
        sendTextButton.addEventListener('click', sendText);
        sendSampleGcodeButton.addEventListener('click', sendSampleGcode);
        disconnectButton.addEventListener('click', disconnectDevice);
        resetToSampleButton.addEventListener('click', resetToSample);
        gcodeTextarea.addEventListener('input', (e) => parseAndRenderGcode(e.target.value));
        thicknessSlider.addEventListener('input', (e) => {
            const v = parseFloat(e.target.value);
            currentStrokeWidth = isFinite(v) ? v : 2.0;
            thicknessValue.textContent = `${currentStrokeWidth.toFixed(1)} mm`;
            parseAndRenderGcode(gcodeTextarea.value || '');
        });

        // Initialize textarea with sample and render preview
        (function initSample() {
            const g = buildSampleGcode();
            gcodeTextarea.value = g;
            parseAndRenderGcode(g);
        })();
    </script>
</body>
</html>
