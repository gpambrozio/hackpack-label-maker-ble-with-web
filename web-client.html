<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Label Maker Client</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Rubik:wght@400;600;800&display=swap"
        rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <!-- QR code generator (MIT) -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.js"></script>
    <style>
        :root {
            --bg: #0b0b0c;
            /* deep black, painted plywood */
            --panel: #111213;
            --panel-2: #17181a;
            /* purple touches */
            --wood-1: #a47148;
            /* warm plywood core */
            --wood-2: #8b5e3c;
            --wood-3: #c18f59;
            --text: #e5e7eb;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: radial-gradient(1200px 800px at 15% 10%, rgba(124, 58, 237, .12), transparent 60%),
                radial-gradient(1000px 700px at 85% 90%, rgba(124, 58, 237, .1), transparent 55%),
                var(--bg);
            color: var(--text);
        }

        /* Device "case" with wood rails */
        .device-case {
            position: relative;
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            box-shadow: 0 20px 60px rgba(0, 0, 0, .6), inset 0 1px 0 rgba(255, 255, 255, .06);
            overflow: visible;
            display: flex;
            flex-direction: column;
            min-height: calc(100vh - 2rem);
            /* fill screen minus body padding */
            isolation: isolate;
        }

        .device-case::before,
        .device-case::after {
            content: '';
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        /* subtle brushed effect */
        .device-case::before {
            background: repeating-linear-gradient(90deg, rgba(255, 255, 255, .03), rgba(255, 255, 255, .03) 2px, transparent 2px, transparent 6px);
            mix-blend-mode: overlay;
            opacity: .3;
        }

        /* wood rails */
        .wood-rails {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 0;
        }

        .wood-rail {
            position: absolute;
            height: 20px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, .08), inset 0 -1px 0 rgba(0, 0, 0, .55), 0 2px 8px rgba(0, 0, 0, .6);
        }

        .wood-rail.top {
            top: 10px;
        }

        .wood-rail.bottom {
            bottom: 10px;
        }

        .wood-grain {
            background:
                linear-gradient(0deg, rgba(0, 0, 0, .15), transparent 20%, transparent 80%, rgba(0, 0, 0, .25)),
                repeating-linear-gradient(0deg, var(--wood-2) 0px, var(--wood-2) 9px, var(--wood-1) 9px, var(--wood-1) 16px, var(--wood-3) 16px, var(--wood-3) 27px);
        }

        /* Engraved label style */
        .engraved {
            font-family: 'Rubik', sans-serif;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            color: #dbc7b6;
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.35), 0 -1px 0 rgba(0, 0, 0, 0.6);
            mix-blend-mode: normal;
        }

        /* Purple screws (decorative) */
        .screw {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #bca6ff, #7c3aed 55%, #4c1d95 90%);
            box-shadow: inset 0 1px 2px rgba(255, 255, 255, .25), 0 2px 8px rgba(124, 58, 237, .35);
            position: absolute;
        }

        /* Button styling */
        .btn {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: .5rem;
            border-radius: 0;
            padding: .8rem 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(180deg, rgba(139, 92, 246, .95), rgba(109, 40, 217, .95));
            box-shadow: 0 8px 22px rgba(124, 58, 237, .35), 0 0 0 1px rgba(124, 58, 237, .35), inset 0 1px 0 rgba(255, 255, 255, .06);
            transition: transform .08s ease, box-shadow .2s ease, filter .2s ease;
        }

        .btn:hover {
            box-shadow: 0 10px 26px rgba(124, 58, 237, .45), 0 0 0 1px rgba(124, 58, 237, .45);
            filter: saturate(1.06);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn[disabled] {
            opacity: .5;
            filter: grayscale(.2);
            cursor: not-allowed;
        }

        .btn-sm {
            padding: .55rem .75rem;
            font-size: .875rem;
            gap: .4rem;
        }

        .btn-secondary {
            background: linear-gradient(180deg, rgba(71, 85, 105, .6), rgba(51, 65, 85, .6));
            backdrop-filter: blur(4px);
            box-shadow: 0 8px 22px rgba(2, 6, 23, .45), 0 0 0 1px rgba(148, 163, 184, .25), inset 0 1px 0 rgba(255, 255, 255, .05);
        }

        /* Inputs */
        .input {
            background: #0f1113;
            border: 1px solid rgba(148, 163, 184, .25);
            color: #e5e7eb;
            border-radius: 0;
            padding: .75rem .9rem;
            outline: none;
            transition: border-color .2s ease, box-shadow .2s ease;
        }

        .input:focus {
            border-color: rgba(124, 58, 237, .8);
            box-shadow: 0 0 0 3px rgba(124, 58, 237, .25);
        }

        /* Slider */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            width: 100%;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            background: linear-gradient(90deg, rgba(124, 58, 237, .8), rgba(124, 58, 237, .35));
            border-radius: 999px;
        }

        input[type="range"]::-moz-range-track {
            height: 6px;
            background: linear-gradient(90deg, rgba(124, 58, 237, .8), rgba(124, 58, 237, .35));
            border-radius: 999px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: radial-gradient(circle at 30% 30%, #bca6ff, #7c3aed 55%, #4c1d95 90%);
            border-radius: 50%;
            margin-top: -6px;
            box-shadow: 0 2px 10px rgba(124, 58, 237, .5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: radial-gradient(circle at 30% 30%, #bca6ff, #7c3aed 55%, #4c1d95 90%);
            border-radius: 50%;
            border: none;
            box-shadow: 0 2px 10px rgba(124, 58, 237, .5);
        }

        /* Preview frame */
        .preview-frame {
            position: relative;
            background: #0f0f10;
            border-radius: 0;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, .06), inset 0 -1px 0 rgba(0, 0, 0, .6), 0 16px 40px rgba(0, 0, 0, .55);
        }

        /* Purple tape surface behind SVG */
        .tape-surface {
            padding: 10px;
            background:
                linear-gradient(180deg, rgba(92, 39, 211, .35), rgba(92, 39, 211, .35)),
                repeating-linear-gradient(135deg, rgba(124, 58, 237, .25) 0px, rgba(124, 58, 237, .25) 6px, rgba(76, 29, 149, .25) 6px, rgba(76, 29, 149, .25) 12px);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, .06), inset 0 -1px 0 rgba(0, 0, 0, .45);
        }

        /* LCD-style status */
        .lcd {
            background: linear-gradient(180deg, #1d3b63, #0f2742);
            color: #d6f0ff;
            border: 1px solid #0a1d33;
            box-shadow: inset 0 1px 6px rgba(0, 0, 0, .6), 0 1px 0 rgba(255, 255, 255, .05);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            letter-spacing: 0.04em;
            text-transform: none;
            padding: .75rem 1rem;
        }

        /* Logo cutout: wooden fill inside text only */
        .logo-cutout {
            font-family: 'Rubik', sans-serif;
            font-weight: 800;
            font-size: 1.25rem;
            letter-spacing: .18em;
            text-transform: uppercase;
            background:
                linear-gradient(0deg, rgba(0, 0, 0, .15), transparent 20%, transparent 80%, rgba(0, 0, 0, .25)),
                repeating-linear-gradient(0deg, var(--wood-2) 0px, var(--wood-2) 9px, var(--wood-1) 9px, var(--wood-1) 16px, var(--wood-3) 16px, var(--wood-3) 27px);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            /* text-shadow: 0 1px 0 rgba(255, 255, 255, .18), 0 -1px 0 rgba(0, 0, 0, .65); */
        }

        /* Tape-style tabs */
        .tabs {
            display: flex;
            gap: .5rem;
            align-items: center;
        }

        .tab {
            user-select: none;
            cursor: pointer;
            border: 1px solid rgba(148, 163, 184, .25);
            padding: .6rem .9rem;
            color: #e5e7eb;
            background: linear-gradient(180deg, rgba(30, 41, 59, .55), rgba(15, 23, 42, .45));
            box-shadow: 0 1px 0 rgba(255, 255, 255, .06) inset, 0 6px 16px rgba(0, 0, 0, .45);
            backdrop-filter: blur(4px);
        }

        .tab:hover {
            filter: saturate(1.05);
        }

        .tab.active {
            color: #fff;
            border-color: rgba(124, 58, 237, .6);
            background:
                linear-gradient(180deg, rgba(92, 39, 211, .55), rgba(92, 39, 211, .55)),
                repeating-linear-gradient(135deg, rgba(124, 58, 237, .25) 0px, rgba(124, 58, 237, .25) 6px, rgba(76, 29, 149, .25) 6px, rgba(76, 29, 149, .25) 12px);
            box-shadow: 0 0 0 1px rgba(124, 58, 237, .35), 0 10px 24px rgba(124, 58, 237, .25);
        }

        /* Drawing UX */
        #gcodePreview {
            touch-action: none;
        }

        .drawing-cursor {
            cursor: crosshair;
        }

        /* SVG Drop Zone */
        .drop-zone {
            border: 2px dashed rgba(124, 58, 237, .5);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            background: rgba(124, 58, 237, .05);
            transition: all .2s ease;
        }

        .drop-zone.drag-over {
            border-color: rgba(124, 58, 237, .8);
            background: rgba(124, 58, 237, .15);
            transform: scale(1.02);
        }

        .drop-zone input[type="file"] {
            display: none;
        }

        .drop-zone-content {
            pointer-events: none;
        }

        /* Compact SVG drop zone for inline use */
        .drop-zone-compact {
            border: 1px dashed rgba(124, 58, 237, .6);
            border-radius: 6px;
            padding: 8px 12px;
            text-align: center;
            background: rgba(124, 58, 237, .08);
            transition: all .2s ease;
            cursor: pointer;
            min-width: 120px;
        }

        .drop-zone-compact:hover {
            border-color: rgba(124, 58, 237, .8);
            background: rgba(124, 58, 237, .12);
        }

        .drop-zone-compact.drag-over {
            border-color: rgba(124, 58, 237, .9);
            background: rgba(124, 58, 237, .2);
        }

        .drop-zone-compact input[type="file"] {
            display: none;
        }

        .drop-zone-compact-content {
            pointer-events: none;
        }
    </style>
</head>

<body class="min-h-screen p-2 md:p-4">
    <div class="w-full device-case py-8 px-2 md:px-8">
        <div class="wood-rails" aria-hidden="true">
            <div class="wood-rail -inset-x-2 md:-inset-x-4 top wood-grain"></div>
            <div class="wood-rail -inset-x-2 md:-inset-x-4 bottom wood-grain"></div>
        </div>

        <div class="flex flex-wrap gap-6 mb-6">
            <!-- Top nameplate -->
            <div class="w-fit  relative z-10 px-4 py-2">
                <span class="logo-cutout">Label Maker</span>

                <!-- Decorative purple joystick/screws cluster -->
                <div class="absolute w-full h-full top-0 left-0">
                    <div class="screw" style="left:0; top:0"></div>
                    <div class="screw" style="right:0; top:0"></div>
                    <div class="screw" style="left:0; bottom:0"></div>
                    <div class="screw" style="right:0; bottom:0"></div>
                </div>
            </div>

            <!-- Toolbar -->
            <div class="flex items-center gap-2">
                <button id="connectButton" class="btn btn-sm">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none">
                        <path d="M7 17L17 7L12 2V22L17 17L7 7" stroke="white" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round" />
                    </svg>
                    Connect
                </button>
                <button id="disconnectButton" class="btn btn-secondary btn-sm" disabled>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M6 12h6m0 0l-3-3m3 3l-3 3M14 6h4a2 2 0 012 2v8a2 2 0 01-2 2h-4" stroke="white"
                            stroke-width="2" stroke-linecap="round" />
                    </svg>
                    Disconnect
                </button>
            </div>

            <div>
                <div id="status" class="lcd text-xs sm:text-sm">
                    Status: Ready to connect.
                </div>
            </div>
        </div>

        <!-- Main content (tabs + sections) -->
        <div class="relative z-10 flex flex-col gap-3 flex-1 min-h-0">
            <div class="tabs">
                <button id="tabGcode" class="tab active">G-code</button>
                <button id="tabText" class="tab">Text</button>
                <button id="tabRaw" class="tab">Raw</button>
            </div>

            <div class="flex-1 min-h-0 overflow-auto">
                <!-- Text section -->
                <section id="sectionText" class="relative z-10 space-y-3 h-full hidden">
                    <div class="space-y-2">
                        <label class="engraved text-sm opacity-80">Text to plot</label>
                        <div class="flex gap-2">
                            <input id="labelText" type="text" placeholder="Enter label text" class="input w-full"
                                maxlength="12" />
                            <button id="sendTextButton" class="btn btn-sm" disabled>
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none"
                                    xmlns="http://www.w3.org/2000/svg">
                                    <path d="M22 2L11 13" stroke="white" stroke-width="2" />
                                    <path d="M22 2l-7 20-4-9-9-4 20-7z" stroke="white" stroke-width="2" fill="none" />
                                </svg>
                                Send
                            </button>
                        </div>
                    </div>
                </section>

                <!-- G-code section -->
                <section id="sectionGcode" class="relative z-10 space-y-3 h-full">
                    <div class="space-y-2">
                        <div class="engraved text-sm opacity-80">G-Code Preview</div>

                        <div class="flex items-center gap-2 flex-wrap">
                            <div class="flex items-center gap-2">
                                <label for="thicknessSlider" class="text-xs text-slate-300 whitespace-nowrap">Tool thickness</label>
                                <input id="thicknessSlider" type="range" min="0.2" max="5" step="0.1" value="2"
                                    class="w-28">
                                <span id="thicknessValue" class="text-xs text-slate-400 whitespace-nowrap">2.0 mm</span>
                            </div>
                            <span class="text-xs text-slate-400 whitespace-nowrap">Area: 260 × 30 mm</span>
                            <button id="toggleDrawButton" class="btn btn-secondary btn-sm"
                                title="Toggle freehand drawing on the preview">
                                Enable Draw
                            </button>
                            <!-- Compact SVG Drop Zone -->
                            <div class="drop-zone-compact" id="svgDropZone" title="Click or drop SVG file to convert to G-code">
                                <input type="file" id="svgFileInput" accept=".svg,image/svg+xml">
                                <div class="drop-zone-compact-content">
                                    <div class="flex items-center gap-2">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="rgba(124, 58, 237, .8)" stroke-width="2">
                                            <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M17 8l-5-5-5 5M12 3v12"/>
                                        </svg>
                                        <span class="text-xs text-purple-300">SVG</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="preview-frame p-0 md:p-2">
                            <div class="tape-surface w-fit">
                                <div class="relative">
                                    <svg id="gcodePreview" class="overflow-visible"
                                        style="max-width: 100%; width: 260mm; aspect-ratio: 260/30; display:block;"
                                        viewBox="0 0 260 30" preserveAspectRatio="xMidYMid meet"></svg>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="space-y-2">
                        <label for="gcodeTextarea" class="engraved text-sm opacity-80">G-code (mm, origin at
                            bottom-left)</label>
                        <textarea id="gcodeTextarea" rows="12" class="input w-full font-mono text-sm"
                            placeholder="Enter G-code here"></textarea>
                        <div class="flex flex-wrap items-center gap-2">
                            <button id="sendSampleGcodeButton" class="btn btn-sm" disabled>Send G-code</button>
                            <button id="clearGCodeButton" class="btn btn-secondary btn-sm" title="Clear G-code input">
                                Clear
                            </button>
                            <button id="generateQrButton" class="btn btn-secondary btn-sm" title="Generate QR code as G-code">Generate QR</button>
                            <button id="resetToSampleButton" class="btn btn-secondary btn-sm"
                                title="Load sample ruler into viewer">Load sample ruler</button>
                            <button id="loadCrunchLabsButton" class="btn btn-secondary btn-sm"
                                title="Load Crunch Labs logo sample into viewer">
                                Load Crunch Labs Logo
                            </button>
                        </div>
                    </div>

                </section>

                <!-- Raw section -->
                <section id="sectionRaw" class="relative z-10 space-y-3 h-full hidden">
                    <div class="flex items-center gap-2">
                        <button id="penDownButton" class="btn btn-sm" disabled>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <path d="M6 18h12M8 14l8-8 2 2-8 8H8v-2z" stroke="white" stroke-width="2"
                                    stroke-linecap="round" stroke-linejoin="round" />
                            </svg>
                            Pen Down
                        </button>
                        <button id="penUpButton" class="btn btn-secondary btn-sm" disabled>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <path d="M6 18h12M16 10l-2-2-6 6v2h2l6-6z" stroke="white" stroke-width="2"
                                    stroke-linecap="round" stroke-linejoin="round" />
                            </svg>
                            Pen Up
                        </button>
                    </div>
                </section>
            </div>
        </div>

        <!-- Status now lives in toolbar -->

        <!-- QR Modal -->
        <div id="qrModal" class="fixed inset-0 z-50 hidden">
            <div id="qrBackdrop" class="absolute inset-0 bg-black/70"></div>
            <div class="relative mx-auto mt-20 w-[min(92vw,640px)] bg-[#0f1113] border border-slate-600/40 shadow-2xl">
                <div class="p-4 border-b border-slate-600/40 flex items-center justify-between">
                    <div class="engraved">Generate QR Code</div>
                    <button id="qrCloseButton" type="button" class="btn-secondary btn-sm">Close</button>
                </div>
                <div class="p-4 space-y-4">
                    <div class="space-y-2">
                        <label class="engraved text-sm opacity-80">Text / URL</label>
                        <input id="qrTextInput" type="text" class="input w-full" placeholder="Enter URL or text" />
                        <p class="text-xs text-slate-400">Tip: Long URLs require a smaller tool thickness (module size) to fit within 30 mm height.</p>
                    </div>
                    <div class="space-y-2">
                        <label class="engraved text-sm opacity-80">Error correction</label>
                        <div class="flex flex-wrap gap-4 text-sm">
                            <label class="inline-flex items-center gap-2"><input type="radio" name="qrEcc" value="L" /> L (7%)</label>
                            <label class="inline-flex items-center gap-2"><input type="radio" name="qrEcc" value="M" checked /> M (15%)</label>
                            <label class="inline-flex items-center gap-2"><input type="radio" name="qrEcc" value="Q" /> Q (25%)</label>
                            <label class="inline-flex items-center gap-2"><input type="radio" name="qrEcc" value="H" /> H (30%)</label>
                        </div>
                    </div>
                    <div class="space-y-2">
                        <label class="engraved text-sm opacity-80">Mode</label>
                        <div class="flex flex-col gap-2 text-sm">
                            <label class="inline-flex items-start gap-2">
                                <input type="radio" name="qrMode" value="inverse" class="mt-1" checked />
                                <span>
                                    <span class="font-semibold">Inverse</span> — light pen on dark paper (draw light squares and a light border/background)
                                </span>
                            </label>
                            <label class="inline-flex items-start gap-2">
                                <input type="radio" name="qrMode" value="normal" class="mt-1" />
                                <span>
                                    <span class="font-semibold">Normal</span> — dark pen on light paper (draw the dark squares)
                                </span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="p-4 border-t border-slate-600/40 flex items-center gap-2 justify-end">
                    <button id="qrCancelButton" type="button" class="btn-secondary btn-sm">Cancel</button>
                    <button id="qrGenerateButton" type="button" class="btn btn-sm">Generate</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables to hold the device and characteristic
        let labelMakerDevice = null;
        let labelMakerCharacteristic = null;

        // UUIDs from the Arduino code
        const SERVICE_UUID = '12345678-1234-5678-1234-56789abcdef0';
        const CHARACTERISTIC_UUID = '87654321-4321-8765-4321-87654321fedc';
        const STATUS_CHARACTERISTIC_UUID = '5f4e3d2c-1b0a-0908-0706-050403020100';

        // Get UI elements
        const connectButton = document.getElementById('connectButton');
        const penDownButton = document.getElementById('penDownButton');
        const penUpButton = document.getElementById('penUpButton');
        const sendTextButton = document.getElementById('sendTextButton');
        const sendSampleGcodeButton = document.getElementById('sendSampleGcodeButton');
        const disconnectButton = document.getElementById('disconnectButton');
        const labelTextInput = document.getElementById('labelText');
        const statusDiv = document.getElementById('status');
        const gcodeTextarea = document.getElementById('gcodeTextarea');
        const resetToSampleButton = document.getElementById('resetToSampleButton');
        const loadCrunchLabsButton = document.getElementById('loadCrunchLabsButton');
        const clearGCodeButton = document.getElementById('clearGCodeButton');
        const gcodePreview = document.getElementById('gcodePreview');
        const thicknessSlider = document.getElementById('thicknessSlider');
        const thicknessValue = document.getElementById('thicknessValue');
        const toggleDrawButton = document.getElementById('toggleDrawButton');
    const generateQrButton = document.getElementById('generateQrButton');
    // QR Modal elements
    const qrModal = document.getElementById('qrModal');
    const qrTextInput = document.getElementById('qrTextInput');
    const qrGenerateButton = document.getElementById('qrGenerateButton');
    const qrCancelButton = document.getElementById('qrCancelButton');
    const qrCloseButton = document.getElementById('qrCloseButton');
    // SVG elements
    const svgDropZone = document.getElementById('svgDropZone');
    const svgFileInput = document.getElementById('svgFileInput');

        // Preview stroke width in mm
        let currentStrokeWidth = 2.0;

    // Track current program kind and QR config for auto-recalc
    let currentProgramKind = 'manual'; // 'manual' | 'qr' | 'svg'
    let currentQrConfig = null; // { text: string, inverse: boolean }
    // Track the last used module size for QR (may be clamped vs. slider value)
    let qrLastUsedModuleSize = null;

        /**
         * Updates the status message on the UI.
         * @param {string} message The message to display.
         */
        const updateStatus = (message) => {
            statusDiv.textContent = `Status: ${message}`;
        };

        /**
         * Connects to the Bluetooth device.
         */
        const connectDevice = async () => {
            try {
                updateStatus('Connecting...');

                // Request a Bluetooth device
                labelMakerDevice = await navigator.bluetooth.requestDevice({
                    // filters: [{ namePrefix: 'LABEL' }],
                    acceptAllDevices: true,
                    optionalServices: [SERVICE_UUID]
                });

                // Add event listener for device disconnects
                labelMakerDevice.addEventListener('gattserverdisconnected', onDisconnected);

                // Connect to the GATT server
                updateStatus('Connecting to GATT server...');
                const server = await labelMakerDevice.gatt.connect();

                // Get the primary service
                updateStatus('Getting service...');
                const service = await server.getPrimaryService(SERVICE_UUID);

                // Get the characteristic
                updateStatus('Getting characteristic...');
                labelMakerCharacteristic = await service.getCharacteristic(CHARACTERISTIC_UUID);
                // Subscribe to status notifications
                try {
                    const statusChar = await service.getCharacteristic(STATUS_CHARACTERISTIC_UUID);
                    await statusChar.startNotifications();
                    statusChar.addEventListener('characteristicvaluechanged', (ev) => {
                        const dv = ev.target.value; // DataView
                        try {
                            // Decode DataView → Uint8Array → UTF-8 string
                            const bytes = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
                            // Ignore spurious single-byte 0x01 frames
                            if (bytes.length === 1 && bytes[0] === 1) return;
                            const dec = new TextDecoder('utf-8', { fatal: false });
                            let msg = dec.decode(bytes);
                            // Remove control chars (except tab/newline/CR) and any NULs
                            msg = msg.replace(/[^\x09\x0A\x0D\x20-\x7E]/g, '').trim();
                            if (!msg) return;
                            updateStatus(msg);
                        } catch (e) {
                            console.warn('Failed to decode status notification:', e, dv);
                        }
                    });
                    // Immediately read current value after subscribing
                    try {
                        const dv = await statusChar.readValue();
                        const bytes = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
                        if (!(bytes.length === 1 && bytes[0] === 1)) {
                            const dec = new TextDecoder('utf-8', { fatal: false });
                            let msg = dec.decode(bytes).replace(/[^\x09\x0A\x0D\x20-\x7E]/g, '').trim();
                            if (msg) updateStatus(msg);
                        }
                    } catch (e) {
                        console.debug('Status read after subscribe failed (non-fatal):', e);
                    }
                } catch (e) {
                    console.warn('Status characteristic not found or notifications failed:', e);
                }

                // No Battery Service in this build

                updateStatus('Connected successfully!');

                // Enable UI elements after successful connection
                connectButton.disabled = true;
                penDownButton.disabled = false;
                penUpButton.disabled = false;
                sendTextButton.disabled = false;
                sendSampleGcodeButton.disabled = false;
                disconnectButton.disabled = false;

            } catch (error) {
                updateStatus(`Connection failed: ${error}`);
                console.error('Connection error:', error);
            }
        };

        /**
         * Write a command string to the device characteristic.
         */
        const writeCommand = async (command) => {
            if (!labelMakerCharacteristic) {
                updateStatus('Not connected!');
                return;
            }
            try {
                //updateStatus('Sending command...');
                const encoder = new TextEncoder();
                const data = encoder.encode(command);
                if (data.byteLength > 512) {
                    throw new Error(`Payload ${data.byteLength} exceeds 512 bytes`);
                }
                await labelMakerCharacteristic.writeValue(data);
                //updateStatus(`Command sent: "${command.slice(0, 60)}${command.length > 60 ? '…' : ''}"`);
            } catch (error) {
                updateStatus(`Failed to send command: ${error}`);
                console.error('Send command error:', error);
            }
        };

        // Write a potentially long G-code using chunked protocol
        const sendGcodeChunked = async (program) => {
            if (!labelMakerCharacteristic) {
                updateStatus('Not connected.');
                return;
            }
            const encoder = new TextEncoder();
            const MAX_PAYLOAD = 480; // leave headroom for command and comma
            try {
                // begin
                updateStatus('Sending G-code: 0%');
                await writeCommand('print-raw-begin,');
                // stream chunks
                let i = 0;
                while (i < program.length) {
                    const slice = program.slice(i, i + MAX_PAYLOAD);
                    // send as print-raw-data,<chunk>
                    await writeCommand(`print-raw-data,${slice}`);
                    const pct = Math.min(100, Math.floor((i + slice.length) / program.length * 100));
                    updateStatus(`Sending G-code: ${pct}%`);
                    i += slice.length;
                }
                // end
                await writeCommand('print-raw-end,');
                updateStatus('G-code sent (chunked).');
            } catch (error) {
                updateStatus(`Chunked send failed: ${error}`);
                console.error('Chunked send error:', error);
            }
        };

        // Build a 5cm-wide ruler-like example with X & Y axes, cm and 0.5cm ticks, and numeric labels (as line strokes)
        // Origin (0,0) is bottom-left. Max area is 260x30 mm; height is capped.
        const buildSampleGcode = () => {
            const AREA_H = 30;
            const MARGIN = 0; // no margin
            const L = MARGIN, B = MARGIN;
            const WIDTH = 50; // 5cm
            const HEIGHT = Math.min(AREA_H - 2 * MARGIN, 50); // cap to available height

            const AXIS_X0 = L, AXIS_Y0 = B;
            const AXIS_X1 = L + WIDTH, AXIS_Y1 = B + HEIGHT;

            const MAJOR = 4; // major tick length (cm)
            const MINOR = 2; // half-cm tick length (5mm)
            const GAP = 1.5; // gap before labels

            // Simple seven-segment digits as line segments within w x h box
            const DIGIT_W = 3, DIGIT_H = 5;
            const segs = {
                A: [0, DIGIT_H, DIGIT_W, DIGIT_H],
                B: [DIGIT_W, DIGIT_H, DIGIT_W, DIGIT_H / 2],
                C: [DIGIT_W, DIGIT_H / 2, DIGIT_W, 0],
                D: [0, 0, DIGIT_W, 0],
                E: [0, DIGIT_H / 2, 0, 0],
                F: [0, DIGIT_H, 0, DIGIT_H / 2],
                G: [0, DIGIT_H / 2, DIGIT_W, DIGIT_H / 2],
            };
            const map = {
                0: ['A', 'B', 'C', 'D', 'E', 'F'],
                1: ['B', 'C'],
                2: ['A', 'B', 'G', 'E', 'D'],
                3: ['A', 'B', 'G', 'C', 'D'],
                4: ['F', 'G', 'B', 'C'],
                5: ['A', 'F', 'G', 'C', 'D'],
                6: ['A', 'F', 'G', 'E', 'C', 'D'],
                7: ['A', 'B', 'C'],
                8: ['A', 'B', 'C', 'D', 'E', 'F', 'G'],
                9: ['A', 'B', 'C', 'D', 'F', 'G'],
            };

            const cmds = [];
            const moveRapid = (x, y) => { cmds.push(`M5`); cmds.push(`G0 X${x} Y${y}`); };
            const drawTo = (x, y) => { cmds.push(`M3`); cmds.push(`G1 X${x} Y${y}`); cmds.push(`M5`); };
            const drawLine = (x1, y1, x2, y2) => { moveRapid(x1, y1); drawTo(x2, y2); };
            const drawDigit = (n, ox, oy) => {
                const seglist = map[n]; if (!seglist) return;
                for (const s of seglist) {
                    const [x1, y1, x2, y2] = segs[s];
                    drawLine(ox + x1, oy + y1, ox + x2, oy + y2);
                }
            };

            // Program header
            cmds.push(`G90`); // absolute
            cmds.push(`M5`);

            // No border rectangle (drop top/right edges and margins)

            // Axes
            drawLine(AXIS_X0, AXIS_Y0, AXIS_X1, AXIS_Y0); // X axis
            drawLine(AXIS_X0, AXIS_Y0, AXIS_X0, AXIS_Y1); // Y axis

            // X-axis ticks and labels (every 5mm, labels at each cm)
            for (let i = 0; i <= WIDTH; i += 5) {
                const x = L + i;
                const len = (i % 10 === 0) ? MAJOR : MINOR;
                drawLine(x, B, x, B + len);
                if (i > 0 && i % 10 === 0) {
                    const n = Math.floor(i / 10);
                    // Center digit above tick
                    const dx = x - DIGIT_W / 2;
                    const dy = B + len + GAP;
                    drawDigit(n, dx, dy);
                }
            }

            // Y-axis ticks and labels (every 5mm, labels at each cm)
            for (let j = 0; j <= HEIGHT; j += 5) {
                const y = B + j;
                const len = (j % 10 === 0) ? MAJOR : MINOR;
                drawLine(L, y, L + len, y);
                if (j > 0 && j % 10 === 0) {
                    const n = Math.floor(j / 10);
                    if (n <= 9) {
                        const dx = L + len + GAP;
                        // vertically center on tick, but keep fully within area height
                        let dy = y - DIGIT_H / 2;
                        const dyMin = B;
                        const dyMax = B + HEIGHT - DIGIT_H;
                        if (dy < dyMin) dy = dyMin;
                        if (dy > dyMax) dy = dyMax;
                        drawDigit(n, dx, dy);
                    }
                }
            }

            return cmds.join(';');
        };

        // Crunch Labs logo sample (excerpt). Uses G21, G90, M3/M5, and F words (ignored by firmware & preview).
        const crunchLogoGcode = `G21
G90;svg > path
M5
G0 X14.23 Y29.99
M3
G1 X13.74 Y29.96
G1 X13.25 Y29.91
G1 X12.76 Y29.84
G1 X12.28 Y29.76
G1 X11.80 Y29.67
G1 X11.32 Y29.55
G1 X10.85 Y29.42
G1 X10.38 Y29.28
G1 X9.92 Y29.12
G1 X9.46 Y28.95
G1 X9.01 Y28.76
G1 X8.56 Y28.55
G1 X8.12 Y28.34
G1 X7.69 Y28.10
G1 X7.26 Y27.86
G1 X6.85 Y27.60
G1 X6.44 Y27.32
G1 X6.04 Y27.04
G1 X5.65 Y26.74
G1 X5.28 Y26.43
G1 X4.91 Y26.10
G1 X4.55 Y25.77
G1 X4.20 Y25.42
G1 X3.87 Y25.06
G1 X3.55 Y24.69
G1 X3.24 Y24.31
G1 X2.94 Y23.92
G1 X2.65 Y23.52
G1 X2.38 Y23.12
G1 X2.12 Y22.70
G1 X1.92 Y22.36
G1 X1.69 Y21.93
G1 X1.47 Y21.49
G1 X1.27 Y21.04
G1 X1.08 Y20.59
G1 X0.90 Y20.13
G1 X0.74 Y19.67
G1 X0.60 Y19.20
G1 X0.47 Y18.73
G1 X0.35 Y18.25
G1 X0.25 Y17.77
G1 X0.17 Y17.29
G1 X0.10 Y16.80
G1 X0.05 Y16.32
G1 X0.02 Y15.83
G1 X0.00 Y15.34
G1 X0.00 Y14.85
G1 X0.01 Y14.36
G1 X0.04 Y13.87
G1 X0.08 Y13.38
G1 X0.14 Y12.89
G1 X0.22 Y12.41
G1 X0.31 Y11.93
G1 X0.42 Y11.45
G1 X0.54 Y10.98
G1 X0.68 Y10.51
G1 X0.84 Y10.04
G1 X1.01 Y9.58
G1 X1.19 Y9.13
G1 X1.39 Y8.68
G1 X1.60 Y8.24
G1 X1.79 Y7.89
G1 X5.23 Y11.33
G1 X5.35 Y11.45
G1 X5.45 Y11.59
G1 X5.54 Y11.73
G1 X5.62 Y11.88
G1 X5.68 Y12.04
G1 X5.72 Y12.21
G1 X5.75 Y12.37
G1 X5.77 Y12.54
G1 X5.77 Y12.71
G1 X5.75 Y12.88
G1 X5.74 Y12.98
G1 X5.66 Y13.36
G1 X5.60 Y13.74
G1 X5.56 Y14.13
G1 X5.53 Y14.52
G1 X5.52 Y14.91
G1 X5.52 Y15.30
G1 X5.54 Y15.69
G1 X5.58 Y16.08
G1 X5.63 Y16.46
G1 X5.69 Y16.84
G1 X5.78 Y17.23
G1 X5.88 Y17.60
G1 X5.99 Y17.97
G1 X6.12 Y18.34
G1 X6.27 Y18.70
G1 X6.42 Y19.06
G1 X6.60 Y19.41
G1 X6.79 Y19.75
G1 X6.99 Y20.08
G1 X7.20 Y20.41
G1 X7.43 Y20.72
G1 X7.67 Y21.03
G1 X7.93 Y21.32
G1 X8.19 Y21.61
G1 X8.47 Y21.88
G1 X8.75 Y22.14
G1 X9.05 Y22.39
G1 X9.36 Y22.63
G1 X9.68 Y22.86
G1 X10.01 Y23.07
G1 X10.32 Y23.25
G1 X10.66 Y23.44
G1 X11.01 Y23.61
G1 X11.37 Y23.77
G1 X11.73 Y23.91
G1 X12.10 Y24.04
G1 X12.47 Y24.15
G1 X12.85 Y24.24
G1 X13.23 Y24.32
G1 X13.62 Y24.39
G1 X14.00 Y24.44
G1 X14.39 Y24.47
G1 X14.78 Y24.49
G1 X15.17 Y24.49
G1 X15.56 Y24.47
G1 X15.95 Y24.44
G1 X16.34 Y24.40
G1 X16.72 Y24.33
G1 X17.10 Y24.26
G1 X17.48 Y24.16
G1 X17.86 Y24.05
G1 X18.22 Y23.93
G1 X18.59 Y23.79
G1 X18.94 Y23.64
G1 X19.29 Y23.47
G1 X19.64 Y23.28
G1 X19.97 Y23.09
G1 X20.30 Y22.87
G1 X20.62 Y22.65
G1 X20.93 Y22.41
G1 X21.22 Y22.16
G1 X21.51 Y21.90
G1 X21.79 Y21.63
G1 X22.06 Y21.35
G1 X22.23 Y21.14
G1 X22.30 Y21.05
G1 X22.36 Y20.94
G1 X22.39 Y20.83
G1 X22.42 Y20.72
G1 X22.43 Y20.61
G1 X22.42 Y20.49
G1 X22.40 Y20.38
G1 X22.36 Y20.27
G1 X22.30 Y20.16
G1 X22.24 Y20.07
G1 X22.16 Y19.99
G1 X22.06 Y19.91
G1 X21.97 Y19.85
G1 X21.86 Y19.81
G1 X21.75 Y19.78
G1 X21.63 Y19.77
G1 X21.58 Y19.76
G1 X14.55 Y19.76
G1 X14.43 Y19.76
G1 X14.32 Y19.73
G1 X14.21 Y19.69
G1 X14.10 Y19.64
G1 X14.01 Y19.57
G1 X13.92 Y19.49
G1 X13.85 Y19.40
G1 X13.81 Y19.34
G1 X11.55 Y15.43
G1 X11.50 Y15.32
G1 X11.46 Y15.21
G1 X11.44 Y15.10
G1 X11.44 Y14.98
G1 X11.45 Y14.86
G1 X11.47 Y14.75
G1 X11.52 Y14.64
G1 X11.55 Y14.57
G1 X13.80 Y10.67
G1 X13.87 Y10.57
G1 X13.95 Y10.48
G1 X14.04 Y10.41
G1 X14.13 Y10.34
G1 X14.24 Y10.30
G1 X14.35 Y10.26
G1 X14.47 Y10.24
G1 X14.55 Y10.24
G1 X21.58 Y10.24
G1 X21.70 Y10.23
G1 X21.81 Y10.21
G1 X21.92 Y10.17
G1 X22.02 Y10.11
G1 X22.12 Y10.05
G1 X22.20 Y9.97
G1 X22.28 Y9.87
G1 X22.33 Y9.78
G1 X22.38 Y9.67
G1 X22.41 Y9.56
G1 X22.42 Y9.44
G1 X22.42 Y9.32
G1 X22.40 Y9.21
G1 X22.37 Y9.10
G1 X22.32 Y8.99
G1 X22.26 Y8.90
G1 X22.23 Y8.85
G1 X21.97 Y8.56
G1 X21.70 Y8.28
G1 X21.42 Y8.01
G1 X21.12 Y7.75
G1 X20.82 Y7.51
G1 X20.51 Y7.28
G1 X20.19 Y7.06
G1 X19.86 Y6.85
G1 X19.52 Y6.66
G1 X19.17 Y6.48
G1 X18.82 Y6.31
G1 X18.46 Y6.16
G1 X18.10 Y6.03
G1 X17.73 Y5.91
G1 X17.35 Y5.81
G1 X16.97 Y5.72
G1 X16.59 Y5.65
G1 X16.20 Y5.59
G1 X15.82 Y5.55
G1 X15.43 Y5.52
G1 X15.04 Y5.51
G1 X14.65 Y5.52
G1 X14.26 Y5.54
G1 X13.87 Y5.58
G1 X13.49 Y5.63
G1 X13.11 Y5.70
G1 X12.92 Y5.74
G1 X12.75 Y5.77
G1 X12.58 Y5.79
G1 X12.41 Y5.78
G1 X12.24 Y5.76
G1 X12.08 Y5.73
G1 X11.91 Y5.68
G1 X11.76 Y5.61
G1 X11.61 Y5.53
G1 X11.47 Y5.44
G1 X11.33 Y5.33
G1 X11.24 Y5.25
G1 X7.82 Y1.82
G1 X8.25 Y1.59
G1 X8.69 Y1.38
G1 X9.14 Y1.18
G1 X9.60 Y1.00
G1 X10.06 Y0.91
G1 X10.52 Y0.68
G1 X10.99 Y0.54
G1 X11.47 Y0.42
G1 X11.95 Y0.31
G1 X12.43 Y0.22
G1 X12.91 Y0.14
G1 X13.40 Y0.08
G1 X13.89 Y0.04
G1 X14.38 Y0.01
G1 X14.87 Y0.00
G1 X15.36 Y0.00
G1 X15.85 Y0.02
G1 X16.33 Y0.06
G1 X16.82 Y0.11
G1 X17.31 Y0.17
G1 X17.79 Y0.26
G1 X18.27 Y0.36
G1 X18.75 Y0.47
G1 X19.22 Y0.60
G1 X19.69 Y0.75
G1 X20.15 Y0.91
G1 X20.61 Y1.08
G1 X21.06 Y1.27
G1 X21.51 Y1.48
G1 X21.95 Y1.70
G1 X22.38 Y1.93
G1 X22.80 Y2.18
G1 X23.21 Y2.44
G1 X23.62 Y2.72
G1 X24.02 Y3.01
G1 X24.40 Y3.31
G1 X24.78 Y3.62
G1 X25.15 Y3.95
G1 X25.50 Y4.28
G1 X25.85 Y4.63
G1 X26.18 Y4.99
G1 X26.50 Y5.36
G1 X26.63 Y5.51
G1 X26.93 Y5.89
G1 X27.22 Y6.29
G1 X27.50 Y6.69
G1 X27.76 Y7.10
G1 X28.01 Y7.52
G1 X28.25 Y7.95
G1 X28.48 Y8.39
G1 X28.68 Y8.83
G1 X28.88 Y9.28
G1 X29.06 Y9.74
G1 X29.22 Y10.20
G1 X29.37 Y10.66
G1 X29.51 Y11.14
G1 X29.62 Y11.61
G1 X29.73 Y12.09
G1 X29.81 Y12.57
G1 X29.89 Y13.06
G1 X29.94 Y13.54
G1 X29.98 Y14.03
G1 X30.01 Y14.52
G1 X30.01 Y15.01
G1 X30.01 Y15.50
G1 X29.98 Y15.99
G1 X29.94 Y16.48
G1 X29.88 Y16.97
G1 X29.81 Y17.45
G1 X29.72 Y17.93
G1 X29.62 Y18.41
G1 X29.50 Y18.89
G1 X29.37 Y19.36
G1 X29.22 Y19.82
G1 X29.05 Y20.29
G1 X28.87 Y20.74
G1 X28.68 Y21.19
G1 X28.47 Y21.63
G1 X28.25 Y22.07
G1 X28.01 Y22.50
G1 X27.76 Y22.92
G1 X27.49 Y23.33
G1 X27.21 Y23.73
G1 X26.92 Y24.13
G1 X26.62 Y24.51
G1 X26.30 Y24.89
G1 X25.97 Y25.25
G1 X25.63 Y25.60
G1 X25.28 Y25.94
G1 X24.92 Y26.27
G1 X24.54 Y26.59
G1 X24.16 Y26.89
G1 X23.77 Y27.19
G1 X23.37 Y27.47
G1 X22.95 Y27.73
G1 X22.53 Y27.99
G1 X22.11 Y28.22
G1 X21.67 Y28.45
G1 X21.23 Y28.66
G1 X20.99 Y28.77
G1 X20.53 Y28.96
G1 X20.07 Y29.13
G1 X19.61 Y29.29
G1 X19.14 Y29.43
G1 X18.67 Y29.56
G1 X18.19 Y29.67
G1 X17.71 Y29.77
G1 X17.23 Y29.85
G1 X16.74 Y29.91
G1 X16.25 Y29.96
G1 X15.76 Y29.99
G1 X15.27 Y30.01
G1 X14.78 Y30.01
G1 X14.29 Y30.00
G1 X14.23 Y29.99
M5`;

        // --- G-code preview renderer (SVG) ---
        const MAX_X = 260, MAX_Y = 30;
        const clearNode = (node) => { while (node.firstChild) node.removeChild(node.firstChild); };
        const parseAndRenderGcode = (program) => {
            clearNode(gcodePreview);

            // Draw area border (tape edges) and keep fill transparent; tape color provided by container
            const border = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            border.setAttribute('x', '0');
            border.setAttribute('y', '0');
            border.setAttribute('width', String(MAX_X));
            border.setAttribute('height', String(MAX_Y));
            border.setAttribute('fill', 'transparent');
            border.setAttribute('stroke', 'rgba(255,255,255,0.25)');
            border.setAttribute('stroke-width', '0.4');
            gcodePreview.appendChild(border);

            // Flip Y so (0,0) is bottom-left visually
            const gg = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            gg.setAttribute('transform', `scale(1,-1) translate(0, -${MAX_Y})`);
            gcodePreview.appendChild(gg);

            let abs = true;
            let pen = false;
            let x = 0, y = 0;
            let path = '';
            // Track if any motion occurred while pen was down; if not, render a dot on pen-up
            let movedSincePenDown = true;
            /** @type {{x:number,y:number}[]} */
            const dots = [];
            const addSeg = (nx, ny) => {
                if (!pen) return;
                if (!path) path = `M ${x} ${y}`;
                path += ` L ${nx} ${ny}`;
                // Mark that movement occurred during current pen-down span
                movedSincePenDown = true;
            };

            const lines = program.split(/[;\n\r]+/);
            for (let raw of lines) {
                let line = raw.replace(/\(.*?\)/g, '').trim();
                if (!line) continue;
                if (line.startsWith(';')) continue;
                line = line.replace(/\s+/g, ' ').toUpperCase();
                const words = line.split(' ');
                const w0 = words[0];
                if (w0.startsWith('G')) {
                    const num = parseInt(w0.slice(1), 10) || 0;
                    let nx = x, ny = y;
                    for (let i = 1; i < words.length; i++) {
                        const w = words[i];
                        if (w.startsWith('X')) nx = parseFloat(w.slice(1));
                        else if (w.startsWith('Y')) ny = parseFloat(w.slice(1));
                    }
                    if (num === 90) { abs = true; continue; }
                    if (num === 91) { abs = false; continue; }
                    if (num === 0 || num === 1) {
                        const tx = abs ? nx : x + nx;
                        const ty = abs ? ny : y + ny;
                        const cx = Math.max(0, Math.min(MAX_X, tx));
                        const cy = Math.max(0, Math.min(MAX_Y, ty));
                        if (num === 1) addSeg(cx, cy);
                        x = cx; y = cy;
                    }
                } else if (w0.startsWith('M')) {
                    const num = parseInt(w0.slice(1), 10) || 0;
                    if (num === 3) { // pen down
                        // start new subpath at current pos always
                        if (path) path += ` M ${x} ${y}`; else path = `M ${x} ${y}`;
                        pen = true;
                        movedSincePenDown = false;
                    } else if (num === 5) { // pen up
                        // If no movement since pen down, this is a "tap" → render as a dot
                        if (pen && !movedSincePenDown) {
                            dots.push({ x, y });
                        }
                        pen = false;
                    } else if (num === 300) {
                        // M300 Sxx heuristic
                        let s = null;
                        for (let i = 1; i < words.length; i++) if (words[i].startsWith('S')) s = parseFloat(words[i].slice(1));
                        if (s !== null) {
                            const down = (s < 60);
                            if (down && !pen) {
                                if (path) path += ` M ${x} ${y}`; else path = `M ${x} ${y}`;
                                pen = true;
                                movedSincePenDown = false;
                            } else if (!down && pen) {
                                if (!movedSincePenDown) {
                                    dots.push({ x, y });
                                }
                                pen = false;
                            }
                        }
                    }
                }
            }

            if (path) {
                const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                p.setAttribute('d', path);
                p.setAttribute('fill', 'none');
                // Silver paint effect on purple tape
                p.setAttribute('stroke', '#d5dbe6');
                p.setAttribute('stroke-opacity', '0.95');
                p.setAttribute('stroke-width', String(currentStrokeWidth));
                p.setAttribute('stroke-linecap', 'round');
                p.setAttribute('stroke-linejoin', 'round');
                gg.appendChild(p);
            }

            // Render any tap dots (M3→M5 with no motion) as filled circles sized to stroke width
            if (dots.length) {
                const r = Math.max(0.01, currentStrokeWidth / 2);
                for (const { x: dx, y: dy } of dots) {
                    const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    c.setAttribute('cx', String(dx));
                    c.setAttribute('cy', String(dy));
                    c.setAttribute('r', String(r));
                    c.setAttribute('fill', '#d5dbe6');
                    c.setAttribute('fill-opacity', '0.95');
                    gg.appendChild(c);
                }
            }
        };

        // --- Freehand drawing → append G-code ---
        let drawEnabled = false;
        let isDrawing = false;
        /** @type {{x:number,y:number}|null} */
        let lastPt = null;
        const MIN_SEG_MM = 0.5; // reduce density

        const appendGcodeLines = (lines) => {
            if (!lines || !lines.length) return;
            let existing = gcodeTextarea.value;
            const needSep = existing.length > 0 && !/[;\n\r]$/.test(existing);
            if (needSep) existing += ';';
            gcodeTextarea.value = existing + lines.join(';');
            parseAndRenderGcode(gcodeTextarea.value);
        };

        const setDrawEnabled = (on) => {
            const enabling = !!on;
            if (!enabling && isDrawing) {
                // finish any active stroke
                appendGcodeLines(['M5']);
                isDrawing = false;
                lastPt = null;
            }
            drawEnabled = enabling;
            toggleDrawButton.textContent = drawEnabled ? 'Disable Draw' : 'Enable Draw';
            gcodePreview.classList.toggle('drawing-cursor', drawEnabled);
        };

        const clientToMM = (e) => {
            const rect = gcodePreview.getBoundingClientRect();
            const sx = MAX_X / rect.width;
            const sy = MAX_Y / rect.height;
            const x = (e.clientX - rect.left) * sx;
            const y = (rect.bottom - e.clientY) * sy; // invert Y so bottom-left origin
            // clamp
            return {
                x: Math.max(0, Math.min(MAX_X, x)),
                y: Math.max(0, Math.min(MAX_Y, y))
            };
        };

        const dist2 = (a, b) => {
            const dx = a.x - b.x, dy = a.y - b.y;
            return dx * dx + dy * dy;
        };

        const round2 = (v) => Math.round(v * 100) / 100;

        // Kept for reference; not used in streaming mode
        const appendStrokeToGcode = (pts) => {
            if (!pts || pts.length < 2) return;
            const fmt = (p) => `X${round2(p.x)} Y${round2(p.y)}`;
            const start = pts[0];
            const lines = ['G90', 'M5', `G0 ${fmt(start)}`, 'M3'];
            for (let i = 1; i < pts.length; i++) lines.push(`G1 ${fmt(pts[i])}`);
            lines.push('M5');
            appendGcodeLines(lines);
        };

        const onPointerDown = (e) => {
            if (!drawEnabled) return;
            // Only main button for mouse, but allow touch/pen
            if (e.pointerType === 'mouse' && e.button !== 0) return;
            e.preventDefault();
            if (isDrawing) return; // guard
            const p = clientToMM(e);
            lastPt = p;
            isDrawing = true;
            // Start stroke immediately: rapid to start, pen down
            const fmt = (pt) => `X${round2(pt.x)} Y${round2(pt.y)}`;
            appendGcodeLines(['G90', 'M5', `G0 ${fmt(p)}`, 'M3']);
            try { gcodePreview.setPointerCapture(e.pointerId); } catch { }
        };

        const onPointerMove = (e) => {
            if (!drawEnabled || !isDrawing) return;
            e.preventDefault();
            const p = clientToMM(e);
            const last = lastPt;
            if (!last || dist2(p, last) >= MIN_SEG_MM * MIN_SEG_MM) {
                const fmt = (pt) => `X${round2(pt.x)} Y${round2(pt.y)}`;
                appendGcodeLines([`G1 ${fmt(p)}`]);
                lastPt = p;
            }
        };

        const endStroke = (e) => {
            if (!isDrawing) return;
            e && e.preventDefault();
            isDrawing = false;
            try { e && gcodePreview.releasePointerCapture(e.pointerId); } catch { }
            appendGcodeLines(['M5']);
            lastPt = null;
        };

        // UI actions
        const sendPenDown = () => writeCommand('pen-down,');
        const sendPenUp = () => writeCommand('pen-up,');
        const sendText = () => {
            const txt = (labelTextInput.value || '').trim();
            if (!txt) {
                updateStatus('Enter some text to print.');
                return;
            }
            if (txt.length > 400) {
                updateStatus('Text too long for single BLE write. Keep under ~400 chars.');
                return;
            }
            writeCommand(`print-text,${txt}`);
            updateStatus(`Sent text: "${txt}"`);
            labelTextInput.value = '';
        };
        const sendSampleGcode = () => {
            const g = (gcodeTextarea.value || '').trim();
            if (!g) {
                updateStatus('No G-code to send.');
                return;
            }
            // decide chunking based on size
            if (g.length > 420) {
                sendGcodeChunked(g);
            } else {
                writeCommand(`print-raw,${g}`);
            }
        };
        const resetToSample = () => {
            const g = buildSampleGcode();
            gcodeTextarea.value = g;
            parseAndRenderGcode(g);
            currentProgramKind = 'manual';
            currentQrConfig = null;
        };

        /**
         * Disconnects from the device.
         */
        const disconnectDevice = () => {
            if (labelMakerDevice && labelMakerDevice.gatt.connected) {
                labelMakerDevice.gatt.disconnect();
                updateStatus('Disconnected.');
            } else {
                updateStatus('Device is already disconnected.');
            }
        };

        /**
         * Handler for when the device unexpectedly disconnects.
         */
        const onDisconnected = () => {
            updateStatus('Device disconnected.');
            // Reset state
            labelMakerDevice = null;
            labelMakerCharacteristic = null;
            connectButton.disabled = false;
            penDownButton.disabled = true;
            penUpButton.disabled = true;
            sendTextButton.disabled = true;
            sendSampleGcodeButton.disabled = true;
            disconnectButton.disabled = true;
        };

        // Attach event listeners to buttons
        connectButton.addEventListener('click', connectDevice);
        penDownButton.addEventListener('click', sendPenDown);
        penUpButton.addEventListener('click', sendPenUp);
        sendTextButton.addEventListener('click', sendText);
        sendSampleGcodeButton.addEventListener('click', sendSampleGcode);
        disconnectButton.addEventListener('click', disconnectDevice);
        resetToSampleButton.addEventListener('click', resetToSample);
        const loadCrunchLabs = () => {
            gcodeTextarea.value = crunchLogoGcode;
            parseAndRenderGcode(crunchLogoGcode);
            updateStatus('Loaded Crunch Labs logo sample into viewer.');
        };
        loadCrunchLabsButton.addEventListener('click', loadCrunchLabs);
        clearGCodeButton.addEventListener('click', () => {
            gcodeTextarea.value = '';
            parseAndRenderGcode('');
            currentProgramKind = 'manual';
            currentQrConfig = null;
        });
        gcodeTextarea.addEventListener('input', (e) => parseAndRenderGcode(e.target.value));
        thicknessSlider.addEventListener('input', async (e) => {
            const v = parseFloat(e.target.value);
            currentStrokeWidth = isFinite(v) ? v : 2.0;
            thicknessValue.textContent = `${currentStrokeWidth.toFixed(1)} mm`;
            // If current view is a QR code, rebuild it with new module size
            if (currentProgramKind === 'qr' && currentQrConfig) {
                try {
                    await ensureQrLib();
                    const g = buildQrGcode(currentQrConfig.text, currentQrConfig.inverse, currentStrokeWidth, currentQrConfig.ecc || 'M');
                    gcodeTextarea.value = g;
                    parseAndRenderGcode(g);
                    if (qrLastUsedModuleSize && Math.abs(qrLastUsedModuleSize - currentStrokeWidth) > 1e-3) {
                        updateStatus(`QR re-generated. Module size clamped to ${qrLastUsedModuleSize.toFixed(2)} mm to fit.`);
                    } else {
                        updateStatus('QR re-generated for new tool thickness.');
                    }
                } catch (err) {
                    updateStatus(String(err));
                    // Keep existing preview
                    parseAndRenderGcode(gcodeTextarea.value || '');
                }
            } else {
                parseAndRenderGcode(gcodeTextarea.value || '');
            }
        });

        // Draw toggle + pointer events
        toggleDrawButton.addEventListener('click', () => setDrawEnabled(!drawEnabled));
        gcodePreview.addEventListener('pointerdown', onPointerDown);
        gcodePreview.addEventListener('pointermove', onPointerMove);
        gcodePreview.addEventListener('pointerup', endStroke);
        gcodePreview.addEventListener('pointercancel', endStroke);
        gcodePreview.addEventListener('pointerleave', endStroke);

        // Tabs
        const tabText = document.getElementById('tabText');
        const tabGcode = document.getElementById('tabGcode');
        const tabRaw = document.getElementById('tabRaw');
        const sectionText = document.getElementById('sectionText');
        const sectionGcode = document.getElementById('sectionGcode');
        const sectionRaw = document.getElementById('sectionRaw');

        const setActiveTab = (target) => {
            const tabs = [tabText, tabGcode, tabRaw];
            const sections = [sectionText, sectionGcode, sectionRaw];
            tabs.forEach((t, i) => {
                const active = t === target;
                t.classList.toggle('active', active);
                sections[i].classList.toggle('hidden', !active);
            });
            // Re-render preview if switching to G-code
            if (target === tabGcode) {
                parseAndRenderGcode(gcodeTextarea.value || '');
            }
        };
        tabText.addEventListener('click', () => setActiveTab(tabText));
        tabGcode.addEventListener('click', () => setActiveTab(tabGcode));
        tabRaw.addEventListener('click', () => setActiveTab(tabRaw));

        // Initialize textarea with sample and render preview
        (function initSample() {
            const g = buildSampleGcode();
            gcodeTextarea.value = g;
            parseAndRenderGcode(g);
        })();

        // ---------------- SVG → G-code ----------------

        // SVG to G-code conversion with proper MoveTo handling
        const convertSvgToGcode = (svgContent) => {
            try {
                // Create a temporary SVG element to parse the content
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
                const svgElement = svgDoc.documentElement;

                if (svgElement.tagName !== 'svg') {
                    throw new Error('Invalid SVG file');
                }

                // Get all path elements
                const paths = svgElement.querySelectorAll('path');
                if (paths.length === 0) {
                    throw new Error('No paths found in SVG. Convert shapes to paths first.');
                }

                const gcode = [];
                gcode.push('G21'); // Millimeter units
                gcode.push('G90'); // Absolute positioning
                gcode.push('M5');  // Pen up initially

                // Get SVG viewBox for scaling
                const viewBox = svgElement.getAttribute('viewBox');
                let scaleX = 1, scaleY = 1, offsetX = 0, offsetY = 0;

                // Scale to fit within 260x30mm area
                const maxWidth = 260;
                const maxHeight = 30;

                if (viewBox) {
                    const [minX, minY, width, height] = viewBox.split(' ').map(Number);
                    scaleX = maxWidth / width;
                    scaleY = maxHeight / height;
                    // Use uniform scaling (maintain aspect ratio)
                    const scale = Math.min(scaleX, scaleY);
                    scaleX = scaleY = scale;
                    offsetX = -minX;
                    offsetY = -minY;
                }

                // Helper to convert SVG coordinates to G-code coordinates
                const convertPoint = (svgX, svgY) => {
                    const x = (svgX + offsetX) * scaleX;
                    const y = (svgY + offsetY) * scaleY;
                    // Flip Y coordinate (SVG has origin at top-left, G-code at bottom-left)
                    const flippedY = maxHeight - y;
                    // Clamp to area bounds
                    return {
                        x: Math.max(0, Math.min(maxWidth, x)),
                        y: Math.max(0, Math.min(maxHeight, flippedY))
                    };
                };

                paths.forEach((path) => {
                    const d = path.getAttribute('d');
                    if (!d) return;

                    // Split path by MoveTo commands to create separate subpaths
                    const subpaths = splitPathByMoveTo(d);

                    subpaths.forEach(subpathData => {
                        if (!subpathData.trim()) return;

                        // Create a temporary path element for each subpath
                        const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        const tempPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        tempPath.setAttribute('d', subpathData);
                        tempSvg.appendChild(tempPath);
                        document.body.appendChild(tempSvg);

                        try {
                            const totalLength = tempPath.getTotalLength();
                            if (totalLength === 0) return; // Skip zero-length paths

                            const numPoints = Math.max(10, Math.floor(totalLength / 0.5)); // Point every 0.5 units

                            // Move to start of subpath
                            const startPoint = tempPath.getPointAtLength(0);
                            const startConverted = convertPoint(startPoint.x, startPoint.y);
                            gcode.push(`G0 X${startConverted.x.toFixed(3)} Y${startConverted.y.toFixed(3)}`);
                            gcode.push('M3'); // Pen down

                            // Sample points along the path
                            for (let i = 1; i <= numPoints; i++) {
                                const distance = (i / numPoints) * totalLength;
                                const point = tempPath.getPointAtLength(distance);
                                const converted = convertPoint(point.x, point.y);
                                gcode.push(`G1 X${converted.x.toFixed(3)} Y${converted.y.toFixed(3)}`);
                            }

                            gcode.push('M5'); // Pen up after each subpath

                        } finally {
                            document.body.removeChild(tempSvg);
                        }
                    });
                });

                return gcode.join(';');

            } catch (error) {
                throw new Error(`SVG conversion failed: ${error.message}`);
            }
        };

        // Split SVG path data by MoveTo commands
        const splitPathByMoveTo = (pathData) => {
            // Find all MoveTo commands (both M and m) and split the path
            // This regex captures MoveTo commands and everything that follows until the next MoveTo
            const moveToRegex = /[Mm][^Mm]*/g;
            const subpaths = pathData.match(moveToRegex) || [];

            return subpaths.map(subpath => subpath.trim()).filter(subpath => subpath.length > 0);
        };

        // Handle SVG file drop and selection
        const handleSvgFile = (file) => {
            if (!file || !file.type.includes('svg')) {
                updateStatus('Please select a valid SVG file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    updateStatus('Converting SVG to G-code...');
                    const svgContent = e.target.result;
                    const gcode = convertSvgToGcode(svgContent);

                    gcodeTextarea.value = gcode;
                    parseAndRenderGcode(gcode);
                    currentProgramKind = 'svg';
                    currentQrConfig = null;

                    updateStatus(`SVG converted to G-code (${file.name})`);
                } catch (error) {
                    updateStatus(error.message);
                    console.error('SVG conversion error:', error);
                }
            };
            reader.onerror = () => {
                updateStatus('Failed to read SVG file.');
            };
            reader.readAsText(file);
        };

        // SVG Drop zone events
        svgDropZone.addEventListener('click', () => {
            svgFileInput.click();
        });

        svgFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleSvgFile(file);
        });

        svgDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            svgDropZone.classList.add('drag-over');
        });

        svgDropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            svgDropZone.classList.remove('drag-over');
        });

        svgDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            svgDropZone.classList.remove('drag-over');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleSvgFile(files[0]);
            }
        });

        // ---------------- QR → G-code ----------------
        const showQrModal = async () => {
            // defaults
            qrTextInput.value = 'https://tinyurl.com/5n6y9vjh';
            const radios = /** @type {NodeListOf<HTMLInputElement>} */(document.querySelectorAll('input[name="qrMode"]'));
            radios.forEach(r => r.checked = (r.value === 'inverse'));
            const eccRadios = /** @type {NodeListOf<HTMLInputElement>} */(document.querySelectorAll('input[name="qrEcc"]'));
            eccRadios.forEach(r => r.checked = (r.value === 'M'));
            qrModal.classList.remove('hidden');
            // Preload QR lib in the background
            try { await ensureQrLib(); } catch (e) { updateStatus(String(e)); }
        };
        const hideQrModal = () => {
            qrModal.classList.add('hidden');
        };

    generateQrButton.addEventListener('click', () => { updateStatus('Opening QR modal…'); showQrModal(); });
        qrCancelButton.addEventListener('click', hideQrModal);
        qrCloseButton.addEventListener('click', hideQrModal);
        const qrBackdrop = document.getElementById('qrBackdrop');
        qrBackdrop.addEventListener('click', hideQrModal);
        window.addEventListener('keydown', (e) => {
            if (!qrModal.classList.contains('hidden') && e.key === 'Escape') hideQrModal();
        });

        // Utility: clamp + rounding
        const round3 = (v) => Math.round(v * 1000) / 1000;

        // Ensure the QR library is available; lazy-load if missing
        const ensureQrLib = () => new Promise((resolve, reject) => {
            if (typeof window.qrcode === 'function') return resolve(window.qrcode);
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.js';
            script.async = true;
            script.onload = () => {
                if (typeof window.qrcode === 'function') resolve(window.qrcode);
                else reject(new Error('QR library failed to load.'));
            };
            script.onerror = () => reject(new Error('Failed to load QR library (network error).'));
            document.head.appendChild(script);
        });

        /**
         * Build QR code program as G-code.
         * - Normal mode: draw dark modules as dots (M3;M5). Finder outer ring as single rectangle path; inner 3x3 filled with horizontal lines.
         * - Inverse mode: draw light modules including a 1-module border as horizontal line segments (scanline fill).
         * @param {string} text
         * @param {boolean} inverse
         * @param {number} moduleSizeMm Module size in mm (uses currentStrokeWidth)
         * @returns {string}
         */
        const buildQrGcode = (text, inverse = true, moduleSizeMm = currentStrokeWidth, ecc = 'M') => {
            if (typeof window.qrcode !== 'function') throw new Error('QR library not loaded.');
            const requestedMs = Math.max(0.1, Number(moduleSizeMm) || 0.2);
            // Build QR at smallest version that fits text (independent of module size)
            const eccUp = String(ecc || 'M').toUpperCase();
            const eccVal = (eccUp === 'L' || eccUp === 'M' || eccUp === 'Q' || eccUp === 'H') ? eccUp : 'M';
            const qr = window.qrcode(0, eccVal);
            qr.addData(text);
            qr.make();
            const n = qr.getModuleCount(); // modules per side

            // Layout calculations
            const BORDER = inverse ? 1 : 0; // 1-module border acts as background in inverse mode
            const totalMods = n + 2 * BORDER;
            // Fit constraint with half-stroke inset on all sides:
            // totalMods*ms <= MAX - ms  => ms*(totalMods + 1) <= MAX  => ms <= MAX/(totalMods+1)
            // Width uses preview width (MAX_X). Height uses relaxed QR limit: 32mm (do not change UI/preview area).
            const msLimitW = MAX_X / (totalMods + 1);
            const QR_MAX_H_MM = 32; // relaxed QR-only vertical bound
            const msLimitH = QR_MAX_H_MM / (totalMods + 1);
            const ms = Math.max(0.1, Math.min(requestedMs, msLimitW, msLimitH));
            qrLastUsedModuleSize = ms;
            // Place bottom-left with half-stroke inset
            const x0 = ms / 2;
            const y0 = ms / 2;

            // Convert grid coords (big grid, includes border if any) to mm center
            const toMM = (rB, cB) => {
                const cx = x0 + (cB + 0.5) * ms;
                const cy = y0 + (totalMods - (rB + 0.5)) * ms; // invert Y (row 0 is top)
                return { x: round3(cx), y: round3(cy) };
            };

            /** Move/Draw helpers */
            const cmds = [];
            const rapid = (x, y) => { cmds.push('M5'); cmds.push(`G0 X${round3(x)} Y${round3(y)}`); };
            const lineTo = (x, y) => { cmds.push('M3'); cmds.push(`G1 X${round3(x)} Y${round3(y)}`); cmds.push('M5'); };
            const dotAt = (x, y) => { cmds.push('M5'); cmds.push(`G0 X${round3(x)} Y${round3(y)}`); cmds.push('M3'); cmds.push('M5'); };

            cmds.push('G90');
            cmds.push('M5');

            if (!inverse) {
                // Normal mode: draw finders as lines; rest dark modules as dots
                // Finder squares positions in QR grid (not including border): 7x7 at TL (0,0), TR (0,n-7), BL (n-7,0)
                const finders = [
                    { r0: 0, c0: 0 },
                    { r0: 0, c0: n - 7 },
                    { r0: n - 7, c0: 0 },
                ];
                // Mark skip mask for finder areas (7x7)
                const skip = new Set();
                const key = (r, c) => `${r},${c}`;

                for (const f of finders) {
                    const { r0, c0 } = f;
                    // Outer ring: draw each edge as an individual stroke with pen lift between segments
                    const tl = toMM(r0 + BORDER, c0 + BORDER);
                    const tr = toMM(r0 + BORDER, c0 + 6 + BORDER);
                    const br = toMM(r0 + 6 + BORDER, c0 + 6 + BORDER);
                    const bl = toMM(r0 + 6 + BORDER, c0 + BORDER);
                    // Top edge TL -> TR
                    rapid(tl.x, tl.y);
                    lineTo(tr.x, tr.y);
                    // Right edge TR -> BR
                    rapid(tr.x, tr.y);
                    lineTo(br.x, br.y);
                    // Bottom edge BR -> BL
                    rapid(br.x, br.y);
                    lineTo(bl.x, bl.y);
                    // Left edge BL -> TL
                    rapid(bl.x, bl.y);
                    lineTo(tl.x, tl.y);

                    // Inner 3x3 filled with horizontal lines (lift per line)
                    for (let rr = r0 + 2; rr <= r0 + 4; rr++) {
                        const pL = toMM(rr + BORDER, (c0 + 2) + BORDER);
                        const pR = toMM(rr + BORDER, (c0 + 4) + BORDER);
                        rapid(pL.x, pL.y);
                        lineTo(pR.x, pR.y);
                    }

                    // Mark skip for whole 7x7 area so we don't dot over finder
                    for (let rr = r0; rr < r0 + 7; rr++) {
                        for (let cc = c0; cc < c0 + 7; cc++) {
                            skip.add(key(rr, cc));
                        }
                    }
                }

                // Dots for remaining dark modules
                for (let r = 0; r < n; r++) {
                    for (let c = 0; c < n; c++) {
                        if (skip.has(key(r, c))) continue;
                        if (qr.isDark(r, c)) {
                            const p = toMM(r + BORDER, c + BORDER);
                            dotAt(p.x, p.y); // single tap per pixel
                        }
                    }
                }
            } else {
                // Inverse mode: draw all light modules including 1-module border as scanline segments
                const isLightBig = (rB, cB) => {
                    const inside = rB >= BORDER && rB < BORDER + n && cB >= BORDER && cB < BORDER + n;
                    if (!inside) return true; // border is background
                    const r = rB - BORDER, c = cB - BORDER;
                    return !qr.isDark(r, c);
                };

                for (let rB = 0; rB < totalMods; rB++) {
                    let runStart = -1;
                    for (let cB = 0; cB <= totalMods; cB++) {
                        const light = cB < totalMods ? isLightBig(rB, cB) : false; // sentinel false to flush
                        if (light) {
                            if (runStart === -1) runStart = cB;
                        } else if (runStart !== -1) {
                            const start = toMM(rB, runStart);
                            const end = toMM(rB, cB - 1);
                            rapid(start.x, start.y);
                            lineTo(end.x, end.y);
                            runStart = -1;
                        }
                    }
                }
            }

            return cmds.join(';');
        };

        const onQrGenerate = async () => {
            const text = (qrTextInput.value || '').trim();
            if (!text) {
                updateStatus('Enter text to encode as QR.');
                return;
            }
            const modeRadio = /** @type {HTMLInputElement|null} */(document.querySelector('input[name="qrMode"]:checked'));
            const inverse = !modeRadio || modeRadio.value === 'inverse';
            const eccRadio = /** @type {HTMLInputElement|null} */(document.querySelector('input[name="qrEcc"]:checked'));
            const ecc = (eccRadio && eccRadio.value) ? eccRadio.value.toUpperCase() : 'M';
            try {
                updateStatus('Preparing QR…');
                await ensureQrLib();
                const g = buildQrGcode(text, inverse, currentStrokeWidth, ecc);
                // Clear and insert new QR program
                gcodeTextarea.value = g;
                parseAndRenderGcode(g);
                currentProgramKind = 'qr';
                currentQrConfig = { text, inverse, ecc };
                setActiveTab(tabGcode);
                if (qrLastUsedModuleSize && Math.abs(qrLastUsedModuleSize - currentStrokeWidth) > 1e-3) {
                    updateStatus(`QR ready (${inverse ? 'inverse' : 'normal'}). Module size clamped to ${qrLastUsedModuleSize.toFixed(2)} mm to fit.`);
                } else {
                    updateStatus(`QR ready (${inverse ? 'inverse' : 'normal'}). Module size ${currentStrokeWidth.toFixed(2)} mm.`);
                }
                hideQrModal();
            } catch (err) {
                updateStatus(String(err));
            }
        };

        qrGenerateButton.addEventListener('click', onQrGenerate);
        qrTextInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                onQrGenerate();
            }
        });
    </script>
</body>

</html>